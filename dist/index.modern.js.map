{"version":3,"file":"index.modern.js","sources":["../src/utils.ts","../src/index.ts"],"sourcesContent":["export const KEY = \"streak\";\nexport interface Streak {\n  currentCount: number;\n  startDate: string;\n  lastLoginDate: string;\n}\n\nexport function formattedDate(date: Date): string {\n  return date.toLocaleDateString(\"en-US\");\n}\n\nexport function buildStreak(\n  date: Date,\n  overrideDefaults?: Partial<Streak>\n): Streak {\n  const defaultStreak = {\n    currentCount: 1,\n    startDate: formattedDate(date),\n    lastLoginDate: formattedDate(date),\n  };\n\n  return {\n    ...defaultStreak,\n    ...overrideDefaults,\n  };\n}\n\nexport function updateStreak(storage: Storage, streak: Streak): void {\n  storage.setItem(KEY, JSON.stringify(streak));\n}\n","import { buildStreak, Streak, updateStreak } from \"./utils\";\nimport { KEY, formattedDate } from \"./utils\";\n\nfunction shouldIncrementOrResetStreakCount(\n  currentDate: Date,\n  lastLoginDate: string\n): \"increment\" | \"reset\" | \"none\" {\n  // We get 11/5/2021\n  // so to get 5, we split on / and get the second item\n  const difference =\n    currentDate.getDate() - parseInt(lastLoginDate.split(\"/\")[1]);\n\n  // Same day login, do nothing\n  if (difference === 0) return \"none\";\n\n  // This means they logged in the day after the currentDate\n  if (difference === 1) {\n    return \"increment\";\n  }\n  // Otherwise they logged in after a day, which would\n  // break the streak\n  return \"reset\";\n}\n\nexport function streakCounter(storage: Storage, date: Date): Streak {\n  const streakInLocalStorage = storage.getItem(KEY);\n  if (streakInLocalStorage) {\n    try {\n      const streak = JSON.parse(streakInLocalStorage) as Streak;\n      const state = shouldIncrementOrResetStreakCount(\n        date,\n        streak.lastLoginDate\n      );\n      const SHOULD_INCREMENT = state === \"increment\";\n      const SHOULD_RESET = state === \"reset\";\n\n      if (SHOULD_INCREMENT) {\n        const updatedStreak = buildStreak(date, {\n          startDate: streak.startDate,\n          currentCount: streak.currentCount + 1,\n          lastLoginDate: formattedDate(date),\n        });\n\n        updateStreak(storage, updatedStreak);\n\n        return updatedStreak;\n      }\n      if (SHOULD_RESET) {\n        const updatedStreak = buildStreak(date);\n\n        updateStreak(storage, updatedStreak);\n\n        return updatedStreak;\n      }\n\n      return streak;\n    } catch (error) {\n      console.error(\"Failed to parse stream from localStorage\");\n    }\n  }\n\n  const streak = buildStreak(date);\n\n  storage.setItem(KEY, JSON.stringify(streak));\n\n  return streak;\n}\n"],"names":["KEY","formattedDate","date","toLocaleDateString","buildStreak","overrideDefaults","_extends","currentCount","startDate","lastLoginDate","updateStreak","storage","streak","setItem","JSON","stringify","streakCounter","streakInLocalStorage","getItem","parse","state","currentDate","difference","getDate","parseInt","split","shouldIncrementOrResetStreakCount","SHOULD_RESET","updatedStreak","error","console"],"mappings":"sNAAaA,EAAM,SAOHC,SAAAA,EAAcC,GAC5B,OAAOA,EAAKC,mBAAmB,SAGjB,SAAAC,EACdF,EACAG,GAQA,OAAAC,EAAA,GANsB,CACpBC,aAAc,EACdC,UAAWP,EAAcC,GACzBO,cAAeR,EAAcC,IAK1BG,GAISK,SAAAA,EAAaC,EAAkBC,GAC7CD,EAAQE,QAAQb,EAAKc,KAAKC,UAAUH,ICJtB,SAAAI,EAAcL,EAAkBT,GAC9C,MAAMe,EAAuBN,EAAQO,QAAQlB,GAC7C,GAAIiB,EACF,IACE,MAAML,EAASE,KAAKK,MAAMF,GACpBG,EA1BZ,SACEC,EACAZ,GAIA,MAAMa,EACJD,EAAYE,UAAYC,SAASf,EAAcgB,MAAM,KAAK,IAG5D,OAAmB,IAAfH,EAAyB,OAGV,IAAfA,EACK,YAIF,QAQWI,CACZxB,EACAU,EAAOH,eAGHkB,EAAyB,UAAVP,EAErB,GAHmC,cAAVA,EAGH,CACpB,MAAMQ,EAAgBxB,EAAYF,EAAM,CACtCM,UAAWI,EAAOJ,UAClBD,aAAcK,EAAOL,aAAe,EACpCE,cAAeR,EAAcC,KAK/B,OAFAQ,EAAaC,EAASiB,GAEfA,EAET,GAAID,EAAc,CAChB,MAAMC,EAAgBxB,EAAYF,GAIlC,OAFAQ,EAAaC,EAASiB,GAEfA,EAGT,OAAOhB,EACP,MAAOiB,GACPC,QAAQD,MAAM,4CAIlB,MAAMjB,EAASR,EAAYF,GAI3B,OAFAS,EAAQE,QAAQb,EAAKc,KAAKC,UAAUH,IAE7BA"}